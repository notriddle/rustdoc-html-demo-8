{"chapters":{"undefined":{"doc":"","selection":{"ranges":[{"anchor":0,"head":0}],"main":0},"scrollTop":0},"editions/index.md":{"doc":"# What are Editions?\n\nThe release of Rust 1.0\n([in May 2015](https://blog.rust-lang.org/2015/05/15/Rust-1.0.html))\nestablished\n[\"stability without stagnation\"](https://blog.rust-lang.org/2014/10/30/Stability.html)\nas a core Rust deliverable.\nEver since the 1.0 release,\nthe rule for Rust has been that once a feature has been released on stable,\nwe are committed to supporting that feature for all future releases.\n\nThere are times, however, when it is useful to be able to make small changes\nto the language that are not backwards compatible.\nThe most obvious example is introducing a new keyword,\nwhich would invalidate variables with the same name.\nFor example, the first version of Rust did not have the `async` and `await` keywords.\nSuddenly changing those words to keywords in a later version would've broken code like `let async = 1;`.\n\n**Editions** are the mechanism we use to solve this problem.\nWhen we want to release a feature that would otherwise be backwards incompatible,\nwe do so as part of a new Rust *edition*.\nEditions are opt-in, and so existing crates do\nnot see these changes until they explicitly migrate over to the new edition.\nThis means that even the latest version of Rust will still *not* treat `async` as a keyword,\nunless edition 2018 or later is chosen.\nThis choice is made *per crate* [as part of its `Cargo.toml`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field).\nNew crates created by `cargo new` are always configured to use the latest stable edition.\n\n### Editions do not split the ecosystem\n\nThe most important rule for editions is that crates in one edition can\ninteroperate seamlessly with crates compiled in other editions. This ensures\nthat the decision to migrate to a newer edition is a \"private one\" that the\ncrate can make without affecting others.\n\nThe requirement for crate interoperability implies some limits on the kinds of\nchanges that we can make in an edition.\nIn general, changes that occur in an edition tend to be \"skin deep\".\nAll Rust code, regardless of edition,\nis ultimately compiled to the same internal representation within the compiler.\n\n### Edition migration is easy and largely automated\n\nOur goal is to make it easy for crates to upgrade to a new edition.\nWhen we release a new edition,\nwe also provide [tooling to automate the migration](https://doc.rust-lang.org/cargo/commands/cargo-fix.html).\nIt makes minor changes to your code necessary to make it compatible with the new edition.\nFor example, when migrating to Rust 2018, it changes anything named `async` to use the equivalent\n[raw identifier syntax](https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html): `r#async`.\n\nThe automated migrations are not necessarily perfect:\nthere might be some corner cases where manual changes are still required.\nThe tooling tries hard to avoid changes\nto semantics that could affect the correctness or performance of the code.\n\nIn addition to tooling, we also maintain this Rust Edition Guide that covers\nthe changes that are part of an edition.\nThis guide describes each change and gives pointers to where you can learn more about it.\nIt also covers any corner cases or details you should be aware of.\nThis guide serves as an overview of editions,\nas a migration guide for specific editions,\nand as a quick troubleshooting reference\nif you encounter problems with the automated tooling.\n","selection":{"ranges":[{"anchor":21,"head":21}],"main":0},"scrollTop":0},"rust-2018/path-changes.md":{"doc":"# Path and module system changes\n\n![Minimum Rust version: 1.31](https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg)\n\n## Summary\n\n- Paths in `use` declarations now work the same as other paths.\n- Paths starting with `::` must now be followed with an external crate.\n- Paths in `pub(in path)` visibility modifiers must now start with `crate`, `self`, or `super`.\n\n## Motivation\n\nThe module system is often one of the hardest things for people new to Rust. Everyone\nhas their own things that take time to master, of course, but there's a root\ncause for why it's so confusing to many: while there are simple and\nconsistent rules defining the module system, their consequences can feel\ninconsistent, counterintuitive and mysterious.\n\nAs such, the 2018 edition of Rust introduces a few new module system\nfeatures, but they end up *simplifying* the module system, to make it more\nclear as to what is going on.\n\nHere's a brief summary:\n\n* `extern crate` is no longer needed in 99% of circumstances.\n* The `crate` keyword refers to the current crate.\n* Paths may start with a crate name, even within submodules.\n* Paths starting with `::` must reference an external crate.\n* A `foo.rs` and `foo/` subdirectory may coexist; `mod.rs` is no longer needed\n  when placing submodules in a subdirectory.\n* Paths in `use` declarations work the same as other paths.\n\nThese may seem like arbitrary new rules when put this way, but the mental\nmodel is now significantly simplified overall. Read on for more details!\n\n## More details\n\nLet's talk about each new feature in turn.\n\n### No more `extern crate`\n\nThis one is quite straightforward: you no longer need to write `extern crate` to\nimport a crate into your project. Before:\n\n```rust,ignore\n// Rust 2015\n\nextern crate futures;\n\nmod submodule {\n    use futures::Future;\n}\n```\n\nAfter:\n\n```rust,ignore\n// Rust 2018\n\nmod submodule {\n    use futures::Future;\n}\n```\n\nNow, to add a new crate to your project, you can add it to your `Cargo.toml`,\nand then there is no step two. If you're not using Cargo, you already had to pass\n`--extern` flags to give `rustc` the location of external crates, so you'd just\nkeep doing what you were doing there as well.\n\n> One small note here: `cargo fix` will not currently automate this change. We may\n> have it do this for you in the future.\n\n#### An exception\n\nThere's one exception to this rule, and that's the \"sysroot\" crates. These are the\ncrates distributed with Rust itself.\n\nUsually these are only needed in very specialized situations. Starting in\n1.41, `rustc` accepts the `--extern=CRATE_NAME` flag which automatically adds\nthe given crate name in a way similar to `extern crate`. Build tools may use\nthis to inject sysroot crates into the crate's prelude. Cargo does not have a\ngeneral way to express this, though it uses it for `proc_macro` crates.\n\nSome examples of needing to explicitly import sysroot crates are:\n\n* [`std`]: Usually this is not necessary, because `std` is automatically\n  imported unless the crate is marked with [`#![no_std]`][no_std].\n* [`core`]: Usually this is not necessary, because `core` is automatically\n  imported, unless the crate is marked with [`#![no_core]`][no_core]. For\n  example, some of the internal crates used by the standard library itself\n  need this.\n* [`proc_macro`]: This is automatically imported by Cargo if it is a\n  proc-macro crate starting in 1.42. `extern crate proc_macro;` would be\n  needed if you want to support older releases, or if using another build tool\n  that does not pass the appropriate `--extern` flags to `rustc`.\n* [`alloc`]: Items in the `alloc` crate are usually accessed via re-exports in\n  the `std` crate. If you are working with a `no_std` crate that supports\n  allocation, then you may need to explicitly import `alloc`.\n* [`test`]: This is only available on the [nightly channel], and is usually\n  only used for the unstable benchmark support.\n\n[`alloc`]: ../../alloc/index.html\n[`core`]: ../../core/index.html\n[`proc_macro`]: ../../proc_macro/index.html\n[`std`]: ../../std/index.html\n[`test`]: ../../test/index.html\n[nightly channel]: ../../book/appendix-07-nightly-rust.html\n[no_core]: https://github.com/rust-lang/rust/issues/29639\n[no_std]: ../../reference/names/preludes.html#the-no_std-attribute\n\n#### Macros\n\nOne other use for `extern crate` was to import macros; that's no longer needed.\nMacros may be imported with `use` like any other item. For example, the\nfollowing use of `extern crate`:\n\n```rust,ignore\n#[macro_use]\nextern crate bar;\n\nfn main() {\n    baz!();\n}\n```\n\nCan be changed to something like the following:\n\n```rust,ignore\nuse bar::baz;\n\nfn main() {\n    baz!();\n}\n```\n\n#### Renaming crates\n\nIf you've been using `as` to rename your crate like this:\n\n```rust,ignore\nextern crate futures as f;\n\nuse f::Future;\n```\n\nthen removing the `extern crate` line on its own won't work. You'll need to do this:\n\n```rust,ignore\nuse futures as f;\n\nuse self::f::Future;\n```\n\nThis change will need to happen in any module that uses `f`.\n\n### The `crate` keyword refers to the current crate\n\nIn `use` declarations and in other code, you can refer to the root of the\ncurrent crate with the `crate::` prefix. For instance, `crate::foo::bar` will\nalways refer to the name `bar` inside the module `foo`, from anywhere else in\nthe same crate.\n\nThe prefix `::` previously referred to either the crate root or an external\ncrate; it now unambiguously refers to an external crate. For instance,\n`::foo::bar` always refers to the name `bar` inside the external crate `foo`.\n\n### Extern crate paths\n\nPreviously, using an external crate in a module without a `use` import\nrequired a leading `::` on the path.\n\n```rust,ignore\n// Rust 2015\n\nextern crate chrono;\n\nfn foo() {\n    // this works in the crate root\n    let x = chrono::Utc::now();\n}\n\nmod submodule {\n    fn function() {\n        // but in a submodule it requires a leading :: if not imported with `use`\n        let x = ::chrono::Utc::now();\n    }\n}\n```\n\nNow, extern crate names are in scope in the entire crate, including\nsubmodules.\n\n```rust,ignore\n// Rust 2018\n\nfn foo() {\n    // this works in the crate root\n    let x = chrono::Utc::now();\n}\n\nmod submodule {\n    fn function() {\n        // crates may be referenced directly, even in submodules\n        let x = chrono::Utc::now();\n    }\n}\n```\n\nIf you have a local module or item with the same name as an external crate, a\npath begining with that name will be taken to refer to the local module or\nitem. To explicitly refer to the external crate, use the `::name` form.\n\n\n### No more `mod.rs`\n\nIn Rust 2015, if you have a submodule:\n\n```rust,ignore\n// This `mod` declaration looks for the `foo` module in\n// `foo.rs` or `foo/mod.rs`.\nmod foo;\n```\n\nIt can live in `foo.rs` or `foo/mod.rs`. If it has submodules of its own, it\n*must* be `foo/mod.rs`. So a `bar` submodule of `foo` would live at\n`foo/bar.rs`.\n\nIn Rust 2018 the restriction that a module with submodules must be named\n`mod.rs` is lifted. `foo.rs` can just be `foo.rs`,\nand the submodule is still `foo/bar.rs`. This eliminates the special\nname, and if you have a bunch of files open in your editor, you can clearly\nsee their names, instead of having a bunch of tabs named `mod.rs`.\n\n<table>\n  <thead>\n    <tr>\n      <th>Rust 2015</th>\n      <th>Rust 2018</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>\n<pre>\n.\n├── lib.rs\n└── foo/\n    ├── mod.rs\n    └── bar.rs\n</pre>\n    </td>\n    <td>\n<pre>\n.\n├── lib.rs\n├── foo.rs\n└── foo/\n    └── bar.rs\n</pre>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n### `use` paths\n\n![Minimum Rust version: 1.32](https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg)\n\nRust 2018 simplifies and unifies path handling compared to Rust 2015. In Rust\n2015, paths work differently in `use` declarations than they do elsewhere. In\nparticular, paths in `use` declarations would always start from the crate\nroot, while paths in other code implicitly started from the current scope.\nThose differences didn't have any effect in the top-level module, which meant\nthat everything would seem straightforward until working on a project large\nenough to have submodules.\n\nIn Rust 2018, paths in `use` declarations and in other code work the same way,\nboth in the top-level module and in any submodule. You can use a relative path\nfrom the current scope, a path starting from an external crate name, or a path\nstarting with `::`, `crate`, `super`, or `self`.\n\nCode that looked like this:\n\n```rust,ignore\n// Rust 2015\n\nextern crate futures;\n\nuse futures::Future;\n\nmod foo {\n    pub struct Bar;\n}\n\nuse foo::Bar;\n\nfn my_poll() -> futures::Poll { ... }\n\nenum SomeEnum {\n    V1(usize),\n    V2(String),\n}\n\nfn func() {\n    let five = std::sync::Arc::new(5);\n    use SomeEnum::*;\n    match ... {\n        V1(i) => { ... }\n        V2(s) => { ... }\n    }\n}\n```\n\nwill look exactly the same in Rust 2018, except that you can delete the `extern\ncrate` line:\n\n```rust,ignore\n// Rust 2018\n\nuse futures::Future;\n\nmod foo {\n    pub struct Bar;\n}\n\nuse foo::Bar;\n\nfn my_poll() -> futures::Poll { ... }\n\nenum SomeEnum {\n    V1(usize),\n    V2(String),\n}\n\nfn func() {\n    let five = std::sync::Arc::new(5);\n    use SomeEnum::*;\n    match ... {\n        V1(i) => { ... }\n        V2(s) => { ... }\n    }\n}\n```\n\nThe same code will also work completely unmodified in a submodule:\n\n```rust,ignore\n// Rust 2018\n\nmod submodule {\n    use futures::Future;\n\n    mod foo {\n        pub struct Bar;\n    }\n\n    use foo::Bar;\n\n    fn my_poll() -> futures::Poll { ... }\n\n    enum SomeEnum {\n        V1(usize),\n        V2(String),\n    }\n\n    fn func() {\n        let five = std::sync::Arc::new(5);\n        use SomeEnum::*;\n        match ... {\n            V1(i) => { ... }\n            V2(s) => { ... }\n        }\n    }\n}\n```\n\nThis makes it easy to move code around in a project, and avoids introducing\nadditional complexity to multi-module projects.\n","selection":{"ranges":[{"anchor":0,"head":0}],"main":0},"scrollTop":0},"introduction.md":{"doc":"# Introduction\n\nWelcome to The Rust Edition Guide! \"Editions\" are Rust's way of introducing\nchanges into the language that would not otherwise be backwards\ncompatible.\n\nIn this guide, we'll discuss:\n\n* What editions are\n* Which changes are contained in each edition\n* How to migrate your code from one edition to another\n","selection":{"ranges":[{"anchor":14,"head":14}],"main":0},"scrollTop":0},"editions/advanced-migrations.md":{"doc":"# Advanced migration strategies\n\n## How migrations work\n\n[`cargo fix --edition`][`cargo fix`] works by running the equivalent of [`cargo check`] on your project with special [lints] enabled which will detect code that may not compile in the next edition.\nThese lints include instructions on how to modify the code to make it compatible on both the current and the next edition.\n`cargo fix` applies these changes to the source code, and then runs `cargo check` again to verify that the fixes work.\nIf the fixes fail, then it will back out the changes and display a warning.\n\nChanging the code to be simultaneously compatible with both the current and next edition makes it easier to incrementally migrate the code.\nIf the automated migration does not completely succeed, or requires manual help, you can iterate while staying on the original edition before changing `Cargo.toml` to use the next edition.\n\nThe lints that `cargo fix --edition` apply are part of a [lint group].\nFor example, when migrating from 2018 to 2021, Cargo uses the `rust-2021-compatibility` group of lints to fix the code.\nCheck the [Partial migration](#partial-migration-with-broken-code) section below for tips on using individual lints to help with migration.\n\n`cargo fix` may run `cargo check` multiple times.\nFor example, after applying one set of fixes, this may trigger new warnings which require further fixes.\nCargo repeats this until no new warnings are generated.\n\n## Migrating multiple configurations\n\n`cargo fix` can only work with a single configuration at a time.\nIf you use [Cargo features] or [conditional compilation], then you may need to run `cargo fix` multiple times with different flags.\n\nFor example, if you have code that uses `#[cfg]` attributes to include different code for different platforms, you may need to run `cargo fix` with the `--target` option to fix for different targets.\nThis may require moving your code between machines if you don't have cross-compiling available.\n\nSimilarly, if you have conditions on Cargo features, like `#[cfg(feature = \"my-optional-thing\")]`, it is recommended to use the `--all-features` flag to allow `cargo fix` to migrate all the code behind those feature gates.\nIf you want to migrate feature code individually, you can use the `--features` flag to migrate one at a time.\n\n## Migrating a large project or workspace\n\nYou can migrate a large project incrementally to make the process easier if you run into problems.\n\nIn a [Cargo workspace], each package defines its own edition, so the process naturally involves migrating one package at a time.\n\nWithin a [Cargo package], you can either migrate the entire package at once, or migrate individual [Cargo targets] one at a time.\nFor example, if you have multiple binaries, tests, and examples, you can use specific target selection flags with `cargo fix --edition` to migrate just that one target.\nBy default, `cargo fix` uses `--all-targets`.\n\nFor even more advanced cases, you can specify the edition for each individual target in `Cargo.toml` like this:\n\n```toml\n[[bin]]\nname = \"my-binary\"\nedition = \"2018\"\n```\n\nThis usually should not be required, but is an option if you have a lot of targets and are having difficulty migrating them all together.\n\n## Partial migration with broken code\n\nSometimes the fixes suggested by the compiler may fail to work.\nWhen this happens, Cargo will report a warning indicating what happened and what the error was.\nHowever, by default it will automatically back out the changes it made.\nIt can be helpful to keep the code in the broken state and manually resolve the issue.\nSome of the fixes may have been correct, and the broken fix maybe be *mostly* correct, but just need minor tweaking.\n\nIn this situation, use the `--broken-code` option with `cargo fix` to tell Cargo not to back out the changes.\nThen, you can go manually inspect the error and investigate what is needed to fix it.\n\nAnother option to incrementally migrate a project is to apply individual fixes separately, one at a time.\nYou can do this by adding the individual lints as warnings, and then either running `cargo fix` (without the `--edition` flag) or using your editor or IDE to apply its suggestions if it supports \"Quick Fixes\".\n\nFor example, the 2018 edition uses the [`keyword-idents`] lint to fix any conflicting keywords.\nYou can add `#![warn(keyword_idents)]` to the top of each crate (like at the top of `src/lib.rs` or `src/main.rs`).\nThen, running `cargo fix` will apply just the suggestions for that lint.\n\nYou can see the list of lints enabled for each edition in the [lint group] page, or run the `rustc -Whelp` command.\n\n## Migrating macros\n\nSome macros may require manual work to fix them for the next edition.\nFor example, `cargo fix --edition` may not be able to automatically fix a macro that generates syntax that does not work in the next edition.\n\nThis may be a problem for both [proc macros] and `macro_rules`-style macros.\n`macro_rules` macros can sometimes be automatically updated if the macro is used within the same crate, but there are several situations where it cannot.\nProc macros in general cannot be automatically fixed at all.\n\nFor example, if we migrate a crate containing this (contrived) macro `foo` from 2015 to 2018, `foo` would not be automatically fixed.\n\n```rust\n#[macro_export]\nmacro_rules! foo {\n    () => {\n        let dyn = 1;\n        println!(\"it is {}\", dyn);\n    };\n}\n```\n\nWhen this macro is defined in a 2015 crate, it can be used from a crate of any other edition due to macro hygiene (discussed below).\nIn 2015, `dyn` is a normal identifier and can be used without restriction.\n\nHowever, in 2018, `dyn` is no longer a valid identifier.\nWhen using `cargo fix --edition` to migrate to 2018, Cargo won't display any warnings or errors at all.\nHowever, `foo` won't work when called from any crate.\n\nIf you have macros, you are encouraged to make sure you have tests that fully cover the macro's syntax.\nYou may also want to test the macros by importing and using them in crates from multiple editions, just to ensure it works correctly everywhere.\nIf you run into issues, you'll need to read through the chapters of this guide to understand how the code can be changed to work across all editions.\n\n### Macro hygiene\n\nMacros use a system called \"edition hygiene\" where the tokens within a macro are marked with which edition they come from.\nThis allows external macros to be called from crates of varying editions without needing to worry about which edition it is called from.\n\nLet's take a closer look at the example above that defines a `macro_rules` macro using `dyn` as an identifier.\nIf that macro was defined in a crate using the 2015 edition, then that macro works fine, even if it were called from a 2018 crate where `dyn` is a keyword and that would normally be a syntax error.\nThe `let dyn = 1;` tokens are marked as being from 2015, and the compiler will remember that wherever that code gets expanded.\nThe parser looks at the edition of the tokens to know how to interpret it.\n\nThe problem arises when changing the edition to 2018 in the crate where it is defined.\nNow, those tokens are tagged with the 2018 edition, and those will fail to parse.\nHowever, since we never called the macro from our crate, `cargo fix --edition` never had a chance to inspect the macro and fix it.\n\n<!-- TODO: hopefully someday, the reference will have chapters on how expansion works, and this can link there for actual details. -->\n\n## Documentation tests\n\nAt this time, `cargo fix` is not able to update [documentation tests].\nAfter updating the edition in `Cargo.toml`, you should run `cargo test` to ensure everything still passes.\nIf your documentation tests use syntax that is not supported in the new edition, you will need to update them manually.\n\nIn rare cases, you can manually set the edition for each test.\nFor example, you can use the [`edition2018` annotation][rustdoc-annotation] on the triple backticks to tell `rustdoc` which edition to use.\n\n## Generated code\n\nAnother area where the automated fixes cannot apply is if you have a build script which generates Rust code at compile time (see [Code generation] for an example).\nIn this situation, if you end up with code that doesn't work in the next edition, you will need to manually change the build script to generate code that is compatible.\n\n## Migrating non-Cargo projects\n\nIf your project is not using Cargo as a build system, it may still be possible to make use of the automated lints to assist migrating to the next edition.\nYou can enable the migration lints as described above by enabling the appropriate [lint group].\nFor example, you can use the `#![warn(rust_2021_compatibility)]` attribute or the `-Wrust-2021-compatibility` or `--force-warns=rust-2021-compatibility` [CLI flag].\n\nThe next step is to apply those lints to your code.\nThere are several options here:\n\n* Manually read the warnings and apply the suggestions recommended by the compiler.\n* Use an editor or IDE that supports automatically applying suggestions.\n  For example, [Visual Studio Code] with the [Rust Analyzer extension] has the ability to use the \"Quick Fix\" links to automatically apply suggestions.\n  Many other editors and IDEs have similar functionality.\n* Write a migration tool using the [`rustfix`] library.\n  This is the library that Cargo uses internally to take the [JSON messages] from the compiler and modify the source code.\n  Check the [`examples` directory][rustfix-examples] for examples of how to use the library.\n\n## Writing idiomatic code in a new edition\n\nEditions are not only about new features and removing old ones.\nIn any programming language, idioms change over time, and Rust is no exception.\nWhile old code will continue to compile, it might be written with different idioms today.\n\nFor example, in Rust 2015, external crates must be listed with `extern crate` like this:\n\n```rust,ignore\n// src/lib.rs\nextern crate rand;\n```\n\nIn Rust 2018, it is [no longer necessary](../rust-2018/path-changes.md#no-more-extern-crate) to include these items.\n\n`cargo fix` has the `--edition-idioms` option to automatically transition some of these idioms to the new syntax.\n\n> **Warning**: The current *\"idiom lints\"* are known to have some problems.\n> They may make incorrect suggestions which may fail to compile.\n> The current lints are:\n> * Edition 2018:\n>     * [`unused-extern-crates`]\n>     * [`explicit-outlives-requirements`]\n> * Edition 2021 does not have any idiom lints.\n>\n> The following instructions are recommended only for the intrepid who are willing to work through a few compiler/Cargo bugs!\n> If you run into problems, you can try the `--broken-code` option [described above](#partial-migration-with-broken-code) to make as much progress as possible, and then resolve the remaining issues manually.\n\nWith that out of the way, we can instruct Cargo to fix our code snippet with:\n\n```console\ncargo fix --edition-idioms\n```\n\nAfterwards, the line with `extern crate rand;` in `src/lib.rs` will be removed.\n\nWe're now more idiomatic, and we didn't have to fix our code manually!\n\n[`cargo check`]: ../../cargo/commands/cargo-check.html\n[`cargo fix`]: ../../cargo/commands/cargo-fix.html\n[`explicit-outlives-requirements`]:  ../../rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements\n[`keyword-idents`]: ../../rustc/lints/listing/allowed-by-default.html#keyword-idents\n[`rustfix`]: https://github.com/rust-lang/rustfix\n[`unused-extern-crates`]: ../../rustc/lints/listing/allowed-by-default.html#unused-extern-crates\n[Cargo features]: ../../cargo/reference/features.html\n[Cargo package]: ../../cargo/reference/manifest.html#the-package-section\n[Cargo targets]: ../../cargo/reference/cargo-targets.html\n[Cargo workspace]: ../../cargo/reference/workspaces.html\n[CLI flag]: ../../rustc/lints/levels.html#via-compiler-flag\n[Code generation]: ../../cargo/reference/build-script-examples.html#code-generation\n[conditional compilation]: ../../reference/conditional-compilation.html\n[documentation tests]: ../../rustdoc/documentation-tests.html\n[JSON messages]: ../../rustc/json.html\n[lint group]: ../../rustc/lints/groups.html\n[lints]: ../../rustc/lints/index.html\n[proc macros]: ../../reference/procedural-macros.html\n[Rust Analyzer extension]: https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer\n[rustdoc-annotation]: ../../rustdoc/documentation-tests.html#attributes\n[rustfix-examples]: https://github.com/rust-lang/rustfix/tree/master/examples\n[Visual Studio Code]: https://code.visualstudio.com/\n","selection":{"ranges":[{"anchor":0,"head":0}],"main":0},"scrollTop":3766},"rust-2018/cargo.md":{"doc":"# Cargo changes\n\n## Summary\n\n- If there is a target definition in a `Cargo.toml` manifest, it no longer\n  automatically disables automatic discovery of other targets.\n- Target paths of the form `src/{target_name}.rs` are no longer inferred for\n  targets where the `path` field is not set.\n- `cargo install` for the current directory is no longer allowed, you must\n  specify `cargo install --path .` to install the current package.","selection":{"ranges":[{"anchor":0,"head":0}],"main":0},"scrollTop":0},"editions/creating-a-new-project.md":{"doc":"# Creating a new project\n\nA new project created with Cargo is configured to use the latest edition by\ndefault:\n\n```console\n$ cargo new foo\n     Created binary (application) `foo` project\n$ cat foo/Cargo.toml\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n```\n\nThat `edition = \"2021\"` setting configures your package to be built using the\nRust 2021 edition. No further configuration needed!\n\nYou can use the `--edition <YEAR>` option of `cargo new` to create the project\nusing some specific edition. For example, creating a new project to use the\nRust 2018 edition could be done like this:\n\n```console\n$ cargo new --edition 2018 foo\n     Created binary (application) `foo` project\n$ cat foo/Cargo.toml\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nedition = \"2018\"\n\n[dependencies]\n```\n\nDon't worry about accidentally using an invalid year for the edition; the\n`cargo new` invocation will not accept an invalid edition year value:\n\n```console\n$ cargo new --edition 2019 foo\nerror: \"2019\" isn't a valid value for '--edition <YEAR>'\n        [possible values: 2015, 2018, 2021]\n\n        Did you mean \"2018\"?\n\nFor more information try --help\n```\n\nYou can change the value of the `edition` key by simply editing the\n`Cargo.toml` file. For example, to cause your package to be built using the\nRust 2015 edition, you would set the key as in the following example:\n\n```toml\n[package]\nname = \"foo\"\nversion = \"0.1.0\"\nedition = \"2015\"\n\n[dependencies]\n```\n","selection":{"ranges":[{"anchor":111,"head":111}],"main":0},"scrollTop":0}}}